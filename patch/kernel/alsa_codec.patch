From 31943e9e7232fc51974a10c9c6ad4ab19f183ab9 Mon Sep 17 00:00:00 2001
From: Chaithanya Krishna Bacharaju <chaithan@codeaurora.org>
Date: Mon, 27 Jul 2015 10:32:05 +0530
Subject: [PATCH] ALSA: compress: Add support to send codec specific data

Codec specific  metadata is sent only for first stream in gapless
playback. This causes incorrect configuration to be set for second
stream and distortions are observed due to framedrops in adsp.
Add support to send codec specific format during start of
next stream in gapless using set_next_track_param.

Change-Id: Ieec6b2afedec156e47873efcad9b3571160b0a29
Signed-off-by: Chaithanya Krishna Bacharaju <chaithan@codeaurora.org>
---
 Documentation/sound/alsa/compress_offload.txt |  6 +++
 include/sound/compress_driver.h               |  2 +
 include/sound/compress_offload.h              |  2 +
 sound/core/compress_offload.c                 | 25 +++++++++++
 sound/soc/soc-compress.c                      | 62 +++++++++++++++++----------
 5 files changed, 75 insertions(+), 22 deletions(-)

diff --git a/Documentation/sound/alsa/compress_offload.txt b/Documentation/sound/alsa/compress_offload.txt
index ca93459..044415a 100644
--- a/Documentation/sound/alsa/compress_offload.txt
+++ b/Documentation/sound/alsa/compress_offload.txt
@@ -176,6 +176,11 @@ This is called when end of file is reached. The userspace can inform DSP that
 EOF is reached and now DSP can start skipping padding delay. Also next write
 data would belong to next track
 
+- set_next_track_param
+This routine is called to send to DSP codec specific data of subsequent track
+in gapless before first write.
+
+
 Sequence flow for gapless would be:
 - Open
 - Get caps / codec caps
@@ -187,6 +192,7 @@ Sequence flow for gapless would be:
 - Indicaite next track data by sending set_next_track
 - Set metadata of the next track
 - then call partial_drain to flush most of buffer in DSP
+- set codec specific data of subsequent track
 - Fill data of the next track
 - DSP switches to second track
 (note: order for partial_drain and write for next track can be reversed as well)
diff --git a/include/sound/compress_driver.h b/include/sound/compress_driver.h
index 9baab2a..9dc0416 100644
--- a/include/sound/compress_driver.h
+++ b/include/sound/compress_driver.h
@@ -118,6 +118,8 @@ struct snd_compr_ops {
 			struct snd_compr_metadata *metadata);
 	int (*get_metadata)(struct snd_compr_stream *stream,
 			struct snd_compr_metadata *metadata);
+	int (*set_next_track_param)(struct snd_compr_stream *stream,
+			union snd_codec_options *codec_options);
 	int (*trigger)(struct snd_compr_stream *stream, int cmd);
 	int (*pointer)(struct snd_compr_stream *stream,
 			struct snd_compr_tstamp *tstamp);
diff --git a/include/sound/compress_offload.h b/include/sound/compress_offload.h
index 5a5599a..4490fe2 100644
--- a/include/sound/compress_offload.h
+++ b/include/sound/compress_offload.h
@@ -190,6 +190,8 @@ struct snd_compr_audio_info {
 #define SNDRV_COMPRESS_DRAIN		_IO('C', 0x34)
 #define SNDRV_COMPRESS_NEXT_TRACK	_IO('C', 0x35)
 #define SNDRV_COMPRESS_PARTIAL_DRAIN	_IO('C', 0x36)
+#define SNDRV_COMPRESS_SET_NEXT_TRACK_PARAM\
+					_IOW('C', 0x37, union snd_codec_options)
 /*
  * TODO
  * 1. add mmap support
diff --git a/sound/core/compress_offload.c b/sound/core/compress_offload.c
index bb3d9a4..81ebd3c 100644
--- a/sound/core/compress_offload.c
+++ b/sound/core/compress_offload.c
@@ -747,6 +747,27 @@ static int snd_compr_partial_drain(struct snd_compr_stream *stream)
 	return retval;
 }
 
+static int snd_compr_set_next_track_param(struct snd_compr_stream *stream,
+		unsigned long arg)
+{
+	union snd_codec_options codec_options;
+	int retval;
+
+	/* set next track params when stream is running or has been setup */
+	if (stream->runtime->state != SNDRV_PCM_STATE_SETUP &&
+			stream->runtime->state != SNDRV_PCM_STATE_RUNNING)
+		return -EPERM;
+
+	if (copy_from_user(&codec_options, (void __user *)arg,
+				sizeof(codec_options)))
+		return -EFAULT;
+
+	retval = stream->ops->set_next_track_param(stream, &codec_options);
+	if (retval != 0)
+		return retval;
+	return 0;
+}
+
 static int snd_compress_simple_ioctls(struct file *file,
 				struct snd_compr_stream *stream,
 				unsigned int cmd, unsigned long arg)
@@ -843,6 +864,10 @@ static long snd_compr_ioctl(struct file *f, unsigned int cmd, unsigned long arg)
 		retval = snd_compr_next_track(stream);
 		break;
 
+	case _IOC_NR(SNDRV_COMPRESS_SET_NEXT_TRACK_PARAM):
+		retval = snd_compr_set_next_track_param(stream, arg);
+		break;
+
 	default:
 		mutex_unlock(&stream->device->lock);
 		return snd_compress_simple_ioctls(f, stream, cmd, arg);
diff --git a/sound/soc/soc-compress.c b/sound/soc/soc-compress.c
index 221a294..93c4b55 100644
--- a/sound/soc/soc-compress.c
+++ b/sound/soc/soc-compress.c
@@ -631,6 +631,22 @@ static int soc_compr_copy(struct snd_compr_stream *cstream,
 	return ret;
 }
 
+static int sst_compr_set_next_track_param(struct snd_compr_stream *cstream,
+				union snd_codec_options *codec_options)
+{
+	struct snd_soc_pcm_runtime *rtd = cstream->private_data;
+	struct snd_soc_platform *platform = rtd->platform;
+	int ret = 0;
+
+	if (platform->driver->compr_ops &&
+			platform->driver->compr_ops->set_next_track_param)
+		ret = platform->driver->compr_ops->set_next_track_param(cstream,
+								codec_options);
+
+	return ret;
+}
+
+
 static int sst_compr_set_metadata(struct snd_compr_stream *cstream,
 				struct snd_compr_metadata *metadata)
 {
@@ -658,32 +674,34 @@ static int sst_compr_get_metadata(struct snd_compr_stream *cstream,
 }
 /* ASoC Compress operations */
 static struct snd_compr_ops soc_compr_ops = {
-	.open		= soc_compr_open,
-	.free		= soc_compr_free,
-	.set_params	= soc_compr_set_params,
-	.set_metadata   = sst_compr_set_metadata,
-	.get_metadata	= sst_compr_get_metadata,
-	.get_params	= soc_compr_get_params,
-	.trigger	= soc_compr_trigger,
-	.pointer	= soc_compr_pointer,
-	.ack		= soc_compr_ack,
-	.get_caps	= soc_compr_get_caps,
-	.get_codec_caps = soc_compr_get_codec_caps
+	.open			= soc_compr_open,
+	.free			= soc_compr_free,
+	.set_params		= soc_compr_set_params,
+	.set_metadata		= sst_compr_set_metadata,
+	.set_next_track_param	= sst_compr_set_next_track_param,
+	.get_metadata		= sst_compr_get_metadata,
+	.get_params		= soc_compr_get_params,
+	.trigger		= soc_compr_trigger,
+	.pointer		= soc_compr_pointer,
+	.ack			= soc_compr_ack,
+	.get_caps		= soc_compr_get_caps,
+	.get_codec_caps		= soc_compr_get_codec_caps
 };
 
 /* ASoC Dynamic Compress operations */
 static struct snd_compr_ops soc_compr_dyn_ops = {
-	.open		= soc_compr_open_fe,
-	.free		= soc_compr_free_fe,
-	.set_params	= soc_compr_set_params_fe,
-	.get_params	= soc_compr_get_params,
-	.set_metadata   = sst_compr_set_metadata,
-	.get_metadata	= sst_compr_get_metadata,
-	.trigger	= soc_compr_trigger_fe,
-	.pointer	= soc_compr_pointer,
-	.ack		= soc_compr_ack,
-	.get_caps	= soc_compr_get_caps,
-	.get_codec_caps = soc_compr_get_codec_caps
+	.open			= soc_compr_open_fe,
+	.free			= soc_compr_free_fe,
+	.set_params		= soc_compr_set_params_fe,
+	.get_params		= soc_compr_get_params,
+	.set_metadata		= sst_compr_set_metadata,
+	.set_next_track_param	= sst_compr_set_next_track_param,
+	.get_metadata		= sst_compr_get_metadata,
+	.trigger		= soc_compr_trigger_fe,
+	.pointer		= soc_compr_pointer,
+	.ack			= soc_compr_ack,
+	.get_caps		= soc_compr_get_caps,
+	.get_codec_caps		= soc_compr_get_codec_caps
 };
 
 /* create a new compress */
